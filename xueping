from sklearn.feature_selection import RFE
from sklearn.feature_selection import RFECV
from sklearn.linear_model import LinearRegression,Ridge,Lasso
import numpy as np
import pandas as pd
from pandas import read_csv
from scipy.stats import pearsonr
from sklearn.model_selection import KFold
from sklearn.model_selection import StratifiedKFold
from sklearn.ensemble import RandomForestClassifier

shuju = pd.read_csv(r'C:\Users\win10\Desktop\bishi\data.csv', header=0) #header=0表示

shuju = np.array(shuju)[1:,:]
shuju_new = []
for i in shuju.flat:
    try:
        i = np.float(i)
        shuju_new.append(i)
    except:
        i = np.nan
        shuju_new.append(i)
    else:
        continue
shuju_new = np.array(shuju_new).reshape(np.shape(shuju))
#feature_new = pd.DataFrame(feature_new).dropna(axis=0)
shuju_new = pd.DataFrame(shuju_new).fillna(method='bfill',axis=1)
print(shuju_new)
label = np.array(shuju_new)[:, -1]
feature = np.array(shuju_new)[:, :-1]
print(feature)


rfr = Ridge()

rfecv = RFECV(estimator=rfr, cv=KFold(n_splits=3, random_state=1), scoring='neg_mean_squared_error')
rfecv.fit(feature, label)
print(rfecv.n_features_)
print(rfecv.ranking_)

'''
# lr = LinearRegression()
# 这里一开始选择的是不带正则化的LR
# 但是如果RFE采用的底层模型不稳定的话，RFE就是不稳定的
lr = Ridge(alpha=100000, fit_intercept=True, normalize=True,
           copy_X=True, max_iter=2000, tol=1e-4, solver='auto')

# 这里不带交叉验证的部分
# estimator估计函数
rfe = RFE(estimator=lr, n_features_to_select=100)
rfe.fit(feature,label)
# 和传参对应，所选择的属性的个数
print(rfe.n_features_)

# 打印的是相应位置上属性的排名
print(rfe.ranking_)
# 属性选择的一种模糊表示，选择的是true，未选择的是false
print(rfe.support_)
# 第1个属相的排名
print(rfe.ranking_[1])
# 外部估计函数的相关信息
print(rfe.estimator_)'''
